---
layout: post
title: Guess my key - IRISSCON 2012 Lost Challenges
date: '2013-10-05T01:13:00.000+08:00'
author: Mercurii
tags:
- IRISSCON 2012 Lost Challenges
- WeChall
modified_time: '2013-10-26T12:15:29.068+08:00'
thumbnail: http://3.bp.blogspot.com/-S5kJJQ5_QQ8/Uk729VNlsdI/AAAAAAAABEs/PDZQ_Dph_QQ/s72-c/2013-10-05+00_56_58-Guess+my+Key!.png
blogger_id: tag:blogger.com,1999:blog-2905258938461604888.post-1996092146439788624
blogger_orig_url: http://kectf.blogspot.com/2013/10/guess-my-key-irisscon-2012-lost.html
---

<div class="tr_bq">Guess my key - Medium - 700</div><br />Despite what the title of the challenge says, guessing would get you no where! We are given an executable that checks if the given key is correct.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-S5kJJQ5_QQ8/Uk729VNlsdI/AAAAAAAABEs/PDZQ_Dph_QQ/s1600/2013-10-05+00_56_58-Guess+my+Key!.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img alt="Guess my Key!" border="0" src="http://3.bp.blogspot.com/-S5kJJQ5_QQ8/Uk729VNlsdI/AAAAAAAABEs/PDZQ_Dph_QQ/s1600/2013-10-05+00_56_58-Guess+my+Key!.png" title="" /></a></div><br /><br />Let's open it in IDA. What I would always do in cracking or reversing is to open the Strings subview&nbsp;(Views-&gt;Open Subviews-&gt;Strings / Shift + F12) and try to find a string that says we got the correct key. Then follow the string through XREFs in IDA and we will reach the location or function that checks if the key is correct.<br /><br />loc_401095:<br />So this is the function that checks if the key we provide is correct. It appears that we need to reverse it as the key we provide is the key for this challenge, so we can't just patch the executable.<br /><br />Each byte or character of the key goes through a different process including XORs, Additions (ADD), Subtractions (SUB), and Rotations (ROR, ROL). I've compiled them and created a python script to reverse the process and get back the original key.<br /><pre class="prettyprint">#!/usr/bin/env python<br />import sys<br />def rol(byte, count):<br />&nbsp; &nbsp; while count &gt; 0:<br />&nbsp; &nbsp; &nbsp; &nbsp; byte = (byte &lt;&lt; 1 | byte &gt;&gt; 7) &amp; 0xFF<br />&nbsp; &nbsp; &nbsp; &nbsp; count -= 1<br />&nbsp; &nbsp; return byte<br />def ror(byte, count):<br />&nbsp; &nbsp; while count &gt; 0:<br />&nbsp; &nbsp; &nbsp; &nbsp; byte = (byte &gt;&gt; 1 | byte &lt;&lt; 7) &amp; 0xFF<br />&nbsp; &nbsp; &nbsp; &nbsp; count -= 1<br />&nbsp; &nbsp; return byte<br /><br />result = "" <br />result += "\x64"<br />result += chr(ord("\xDE") ^ ord("\xEA"))<br />result += chr(ord("\x77") ^ ord("\x12"))<br />result += chr((ord("\x52") ^ ord("\x6A")) - 5)<br />result += chr((ord("\x6F") ^ ord("\x48")) + ord("\x0F"))<br />result += chr(ord("\xCB") ^ ord("\xFF"))<br />result += chr((ord("\x75") + ord("\x24")) ^ ord("\xFF"))<br />result += chr((ord("\xB9") - ord("\x1F")) ^ ord("\xFF"))<br />result += chr((ord("\xF1") ^ ord("\x3B") ^ ord("\xFF")))<br />result += chr(ror(ord("\x70"), 1))<br />result += chr(ror((ord("\x9F") ^ ord("\xFF")), 1))<br />result += chr(ror(ord("\xD3") ^ ord("\x1B"), 1))<br />result += chr(rol(ord("\x9B"), 1))<br />result += chr(rol((ord("\x63") ^ ord("\xFF")), 1))<br />result += chr(rol((ord("\xD6") ^ ord("\x4F")), 1))<br />result += chr(((ord("\xD8") ^ ord("\xFF")) ^ ord("\xBB")) ^ ord("\xFF"))<br />print result</pre>Well I think this challenge is straightforward enough.